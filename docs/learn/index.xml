<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Learn on Zig Programming Language</title><link>//ziglang.github.io/www.ziglang.org/learn/</link><description>Recent content in Learn on Zig Programming Language</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="//ziglang.github.io/www.ziglang.org/learn/index.xml" rel="self" type="application/rss+xml"/><item><title>Code Examples</title><link>//ziglang.github.io/www.ziglang.org/learn/samples/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/samples/</guid><description>Memory leak detection Using std.GeneralPurposeAllocator you can easily track double frees and memory leaks.
leak.zig
const std = @import(&amp;quot;std&amp;quot;); pub fn main() !void { var gpalloc = std.heap.GeneralPurposeAllocator(.{}){}; defer std.debug.assert(!gpalloc.deinit()); const alloc = &amp;amp;gpalloc.allocator; const u32_ptr = try alloc.create(u32); // oops I forgot to free! }$ zig build-exe leak.zig $ ./leak error(std): Memory leak detected: /private/var/folders/8m/n62vhdk50yx5514t3sd_wckm0000gn/T/zig_docgen743117711/docgen_tmp/leak.zig:9:38: 0x10ff2796f in main (leak) const u32_ptr = try alloc.create(u32); ^ /Users/kristoff/zig/build/lib/zig/std/start.zig:334:37: 0x10ff29152 in std.start.main (leak) const result = root.</description></item><item><title>Getting started Guide</title><link>//ziglang.github.io/www.ziglang.org/learn/getting-started/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/getting-started/</guid><description/></item><item><title>In-depth Overview</title><link>//ziglang.github.io/www.ziglang.org/learn/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/overview/</guid><description>Feature Highlights Small, simple language Focus on debugging your application rather than debugging your programming language knowledge.
Zig&amp;rsquo;s entire syntax is specified with a 500-line PEG grammar file.
There is no hidden control flow, no hidden memory allocations, no preprocessor, and no macros. If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:</description></item><item><title>Why Zig When There is Already C++, D, and Rust?</title><link>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>//ziglang.github.io/www.ziglang.org/learn/why_zig_rust_d_cpp/</guid><description>No hidden control flow If Zig code doesn&amp;rsquo;t look like it&amp;rsquo;s jumping away to call a function, then it isn&amp;rsquo;t. This means you can be sure that the following code calls only foo() and then bar(), and this is guaranteed without needing to know the types of anything:
var a = b + c.d; foo(); bar(); D has @property functions, which are methods that you call with what looks like field access, so in the above example, c.</description></item></channel></rss>